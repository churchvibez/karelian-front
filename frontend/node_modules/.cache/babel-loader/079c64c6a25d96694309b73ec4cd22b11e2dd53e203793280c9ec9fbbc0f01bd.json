{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar react_1 = require(\"react\");\nvar attributes_to_props_1 = __importDefault(require(\"./attributes-to-props\"));\nvar utilities_1 = require(\"./utilities\");\nvar React = {\n  cloneElement: react_1.cloneElement,\n  createElement: react_1.createElement,\n  isValidElement: react_1.isValidElement\n};\n/**\r\n * Converts DOM nodes to JSX element(s).\r\n *\r\n * @param nodes - DOM nodes.\r\n * @param options - Options.\r\n * @returns - String or JSX element(s).\r\n */\nfunction domToReact(nodes, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var reactElements = [];\n  var hasReplace = typeof options.replace === 'function';\n  var transform = options.transform || utilities_1.returnFirstArg;\n  var _a = options.library || React,\n    cloneElement = _a.cloneElement,\n    createElement = _a.createElement,\n    isValidElement = _a.isValidElement;\n  var nodesLength = nodes.length;\n  for (var index = 0; index < nodesLength; index++) {\n    var node = nodes[index];\n    // replace with custom React element (if present)\n    if (hasReplace) {\n      var replaceElement = options.replace(node, index);\n      if (isValidElement(replaceElement)) {\n        // set \"key\" prop for sibling elements\n        // https://react.dev/learn/rendering-lists#rules-of-keys\n        if (nodesLength > 1) {\n          replaceElement = cloneElement(replaceElement, {\n            key: replaceElement.key || index\n          });\n        }\n        reactElements.push(transform(replaceElement, node, index));\n        continue;\n      }\n    }\n    if (node.type === 'text') {\n      var isWhitespace = !node.data.trim().length;\n      // We have a whitespace node that can't be nested in its parent\n      // so skip it\n      if (isWhitespace && node.parent && !(0, utilities_1.canTextBeChildOfNode)(node.parent)) {\n        continue;\n      }\n      // Trim is enabled and we have a whitespace node\n      // so skip it\n      if (options.trim && isWhitespace) {\n        continue;\n      }\n      // We have a text node that's not whitespace and it can be nested\n      // in its parent so add it to the results\n      reactElements.push(transform(node.data, node, index));\n      continue;\n    }\n    var element = node;\n    var props = {};\n    if (skipAttributesToProps(element)) {\n      (0, utilities_1.setStyleProp)(element.attribs.style, element.attribs);\n      props = element.attribs;\n    } else if (element.attribs) {\n      props = (0, attributes_to_props_1.default)(element.attribs, element.name);\n    }\n    var children = void 0;\n    switch (node.type) {\n      case 'script':\n      case 'style':\n        // prevent text in <script> or <style> from being escaped\n        // https://react.dev/reference/react-dom/components/common#dangerously-setting-the-inner-html\n        if (node.children[0]) {\n          props.dangerouslySetInnerHTML = {\n            __html: node.children[0].data\n          };\n        }\n        break;\n      case 'tag':\n        // setting textarea value in children is an antipattern in React\n        // https://react.dev/reference/react-dom/components/textarea#caveats\n        if (node.name === 'textarea' && node.children[0]) {\n          props.defaultValue = node.children[0].data;\n        } else if (node.children && node.children.length) {\n          // continue recursion of creating React elements (if applicable)\n          children = domToReact(node.children, options);\n        }\n        break;\n      // skip all other cases (e.g., comment)\n      default:\n        continue;\n    }\n    // set \"key\" prop for sibling elements\n    // https://react.dev/learn/rendering-lists#rules-of-keys\n    if (nodesLength > 1) {\n      props.key = index;\n    }\n    reactElements.push(transform(createElement(node.name, props, children), node, index));\n  }\n  return reactElements.length === 1 ? reactElements[0] : reactElements;\n}\nexports.default = domToReact;\n/**\r\n * Determines whether DOM element attributes should be transformed to props.\r\n * Web Components should not have their attributes transformed except for `style`.\r\n *\r\n * @param node - Element node.\r\n * @returns - Whether the node attributes should be converted to props.\r\n */\nfunction skipAttributesToProps(node) {\n  return utilities_1.PRESERVE_CUSTOM_ATTRIBUTES && node.type === 'tag' && (0, utilities_1.isCustomComponent)(node.name, node.attribs);\n}","map":{"version":3,"names":["react_1","require","attributes_to_props_1","__importDefault","utilities_1","React","cloneElement","createElement","isValidElement","domToReact","nodes","options","reactElements","hasReplace","replace","transform","returnFirstArg","_a","library","nodesLength","length","index","node","replaceElement","key","push","type","isWhitespace","data","trim","parent","canTextBeChildOfNode","element","props","skipAttributesToProps","setStyleProp","attribs","style","default","name","children","dangerouslySetInnerHTML","__html","defaultValue","exports","PRESERVE_CUSTOM_ATTRIBUTES","isCustomComponent"],"sources":["D:\\GIT\\projects\\tppo\\karelian-front\\frontend\\node_modules\\html-react-parser\\src\\dom-to-react.ts"],"sourcesContent":["import { cloneElement, createElement, isValidElement } from 'react';\r\nimport type { JSX } from 'react';\r\nimport type { Element, DOMNode, Text } from 'html-dom-parser';\r\n\r\nimport attributesToProps from './attributes-to-props';\r\nimport type { Props } from './attributes-to-props';\r\nimport {\r\n  PRESERVE_CUSTOM_ATTRIBUTES,\r\n  canTextBeChildOfNode,\r\n  isCustomComponent,\r\n  returnFirstArg,\r\n  setStyleProp,\r\n} from './utilities';\r\n\r\nimport type { HTMLReactParserOptions } from './types';\r\n\r\nconst React = {\r\n  cloneElement,\r\n  createElement,\r\n  isValidElement,\r\n} as const;\r\n\r\n/**\r\n * Converts DOM nodes to JSX element(s).\r\n *\r\n * @param nodes - DOM nodes.\r\n * @param options - Options.\r\n * @returns - String or JSX element(s).\r\n */\r\nexport default function domToReact(\r\n  nodes: DOMNode[],\r\n  options: HTMLReactParserOptions = {},\r\n): string | JSX.Element | JSX.Element[] {\r\n  const reactElements = [];\r\n\r\n  const hasReplace = typeof options.replace === 'function';\r\n  const transform = options.transform || returnFirstArg;\r\n  const { cloneElement, createElement, isValidElement } =\r\n    options.library || React;\r\n\r\n  const nodesLength = nodes.length;\r\n\r\n  for (let index = 0; index < nodesLength; index++) {\r\n    const node = nodes[index];\r\n\r\n    // replace with custom React element (if present)\r\n    if (hasReplace) {\r\n      let replaceElement = options.replace!(node, index) as JSX.Element;\r\n\r\n      if (isValidElement(replaceElement)) {\r\n        // set \"key\" prop for sibling elements\r\n        // https://react.dev/learn/rendering-lists#rules-of-keys\r\n        if (nodesLength > 1) {\r\n          replaceElement = cloneElement(replaceElement, {\r\n            key: replaceElement.key || index,\r\n          });\r\n        }\r\n\r\n        reactElements.push(transform(replaceElement, node, index));\r\n        continue;\r\n      }\r\n    }\r\n\r\n    if (node.type === 'text') {\r\n      const isWhitespace = !node.data.trim().length;\r\n\r\n      // We have a whitespace node that can't be nested in its parent\r\n      // so skip it\r\n      if (\r\n        isWhitespace &&\r\n        node.parent &&\r\n        !canTextBeChildOfNode(node.parent as Element)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // Trim is enabled and we have a whitespace node\r\n      // so skip it\r\n      if (options.trim && isWhitespace) {\r\n        continue;\r\n      }\r\n\r\n      // We have a text node that's not whitespace and it can be nested\r\n      // in its parent so add it to the results\r\n      reactElements.push(transform(node.data, node, index));\r\n      continue;\r\n    }\r\n\r\n    const element = node as Element;\r\n    let props: Props = {};\r\n\r\n    if (skipAttributesToProps(element)) {\r\n      setStyleProp(element.attribs.style, element.attribs);\r\n      props = element.attribs;\r\n    } else if (element.attribs) {\r\n      props = attributesToProps(element.attribs, element.name);\r\n    }\r\n\r\n    let children: ReturnType<typeof domToReact> | undefined;\r\n\r\n    switch (node.type) {\r\n      case 'script':\r\n      case 'style':\r\n        // prevent text in <script> or <style> from being escaped\r\n        // https://react.dev/reference/react-dom/components/common#dangerously-setting-the-inner-html\r\n        if (node.children[0]) {\r\n          props.dangerouslySetInnerHTML = {\r\n            __html: (node.children[0] as Text).data,\r\n          };\r\n        }\r\n        break;\r\n\r\n      case 'tag':\r\n        // setting textarea value in children is an antipattern in React\r\n        // https://react.dev/reference/react-dom/components/textarea#caveats\r\n        if (node.name === 'textarea' && node.children[0]) {\r\n          props.defaultValue = (node.children[0] as Text).data;\r\n        } else if (node.children && node.children.length) {\r\n          // continue recursion of creating React elements (if applicable)\r\n          children = domToReact(node.children as Text[], options);\r\n        }\r\n        break;\r\n\r\n      // skip all other cases (e.g., comment)\r\n      default:\r\n        continue;\r\n    }\r\n\r\n    // set \"key\" prop for sibling elements\r\n    // https://react.dev/learn/rendering-lists#rules-of-keys\r\n    if (nodesLength > 1) {\r\n      props.key = index;\r\n    }\r\n\r\n    reactElements.push(\r\n      transform(createElement(node.name, props, children), node, index),\r\n    );\r\n  }\r\n\r\n  return reactElements.length === 1 ? reactElements[0] : reactElements;\r\n}\r\n\r\n/**\r\n * Determines whether DOM element attributes should be transformed to props.\r\n * Web Components should not have their attributes transformed except for `style`.\r\n *\r\n * @param node - Element node.\r\n * @returns - Whether the node attributes should be converted to props.\r\n */\r\nfunction skipAttributesToProps(node: Element): boolean {\r\n  return (\r\n    PRESERVE_CUSTOM_ATTRIBUTES &&\r\n    node.type === 'tag' &&\r\n    isCustomComponent(node.name, node.attribs)\r\n  );\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}